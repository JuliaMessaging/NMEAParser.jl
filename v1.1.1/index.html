<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · NMEAParser.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://NickMcSweeney.github.io/NMEAParser.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>NMEAParser.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NMEAParser"><a class="docs-heading-anchor" href="#NMEAParser">NMEAParser</a><a id="NMEAParser-1"></a><a class="docs-heading-anchor-permalink" href="#NMEAParser" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/NickMcSweeney/NMEAParser.jl">NMEAParser</a>.</p><ul><li><a href="#NMEAParser.DTM"><code>NMEAParser.DTM</code></a></li><li><a href="#NMEAParser.GBS"><code>NMEAParser.GBS</code></a></li><li><a href="#NMEAParser.GGA"><code>NMEAParser.GGA</code></a></li><li><a href="#NMEAParser.GLL"><code>NMEAParser.GLL</code></a></li><li><a href="#NMEAParser.GSA"><code>NMEAParser.GSA</code></a></li><li><a href="#NMEAParser.GSV"><code>NMEAParser.GSV</code></a></li><li><a href="#NMEAParser.NMEAData"><code>NMEAParser.NMEAData</code></a></li><li><a href="#NMEAParser.PASHR"><code>NMEAParser.PASHR</code></a></li><li><a href="#NMEAParser.RMC"><code>NMEAParser.RMC</code></a></li><li><a href="#NMEAParser.SVData"><code>NMEAParser.SVData</code></a></li><li><a href="#NMEAParser.TWPOS"><code>NMEAParser.TWPOS</code></a></li><li><a href="#NMEAParser.VTG"><code>NMEAParser.VTG</code></a></li><li><a href="#NMEAParser.ZDA"><code>NMEAParser.ZDA</code></a></li><li><a href="#Base.parse-Tuple{AbstractString}"><code>Base.parse</code></a></li><li><a href="#Base.pop!-Tuple{NMEAData, Type{GGA}}"><code>Base.pop!</code></a></li><li><a href="#NMEAParser._dms_to_dd-Tuple{SubString, SubString}"><code>NMEAParser._dms_to_dd</code></a></li><li><a href="#NMEAParser._hms_to_secs-Tuple{SubString}"><code>NMEAParser._hms_to_secs</code></a></li><li><a href="#NMEAParser.get_system-Tuple{SubString}"><code>NMEAParser.get_system</code></a></li><li><a href="#NMEAParser.is_string_supported-Tuple{AbstractString}"><code>NMEAParser.is_string_supported</code></a></li><li><a href="#NMEAParser.parse_msg!-Tuple{NMEAData, AbstractString}"><code>NMEAParser.parse_msg!</code></a></li><li><a href="#NMEAParser.pos_convert-Tuple{Char, Float64}"><code>NMEAParser.pos_convert</code></a></li><li><a href="#NMEAParser.update-Tuple{NMEAData, GGA}"><code>NMEAParser.update</code></a></li><li><a href="#NMEAParser.update!-Tuple{NMEAData, GGA}"><code>NMEAParser.update!</code></a></li><li><a href="#NMEAParser.vel_convert-Tuple{Char, Float64}"><code>NMEAParser.vel_convert</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.DTM" href="#NMEAParser.DTM"><code>NMEAParser.DTM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DTM &lt;: NMEAString</code></pre><p>A type that represents a Datum reference (DTM) message, which is one of the types of NMEA messages. NMEA stands for National Marine Electronics Association, and it is a standard protocol for communication between marine electronic devices. A DTM message identifies the local geodetic datum and datum offsets from a reference datum. This sentence is used to define the datum to which a position location, and geographic locations in subsequent sentences, is referenced[^1^][1].</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The system identifier, indicating the source of the message (e.g. &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;UNKNOWN&quot;).</li><li><code>local_datum_code::String</code>: The local datum code (CCC), which can be one of the following values[^1^][1]:<ul><li>W84 – WGS-84</li><li>W72 – WGS-72</li><li>S85 – SGS85</li><li>P90 – PE90</li><li>999 – User-defined IHO datum code</li></ul></li><li><code>local_datum_subcode::String</code>: The local datum subdivision code (x).</li><li><code>lat_offset::Float64</code>: The latitude offset, in minutes (x.x). A negative value indicates south and a positive value indicates north.</li><li><code>long_offset::Float64</code>: The longitude offset, in minutes (x.x). A negative value indicates west and a positive value indicates east.</li><li><code>alt_offset::Float64</code>: The altitude offset, in meters (x.x).</li><li><code>ref_datum::String</code>: The reference datum code (CCC), which can be one of the following values[^1^][1]:<ul><li>W84 – WGS-84</li><li>W72 – WGS-72</li><li>S85 – SGS85</li><li>P90 – PE90</li><li>999 – User-defined IHO datum code</li></ul></li><li><code>valid::Bool</code>: A flag indicating whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items of a DTM sentence. It also takes an optional keyword argument <code>system</code>, which specifies the system identifier. If not given, it defaults to &quot;UNKNOWN&quot;. Another optional keyword argument is <code>valid</code>, which specifies whether the message is valid or not. If not given, it defaults to true.</p><p><strong>Example</strong></p><p><code>$GPDTM,W84,,0.000000,N,0.000000,E,0.0,W84*6F</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L521-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.GBS" href="#NMEAParser.GBS"><code>NMEAParser.GBS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GBS(items::Array{D}; system::AbstractString = &quot;UNKNOWN&quot;, valid = true)</code></pre><p>A struct that represents a GBS NMEA string, which is a message that contains the error estimates of the position fix from a global navigation satellite system (GNSS).</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The name of the system that produced the message.</li><li><code>time::Float64</code>: The time of the message in seconds since midnight UTC.</li><li><code>lat_error::Float64</code>: The expected error in latitude in meters.</li><li><code>long_error::Float64</code>: The expected error in longitude in meters.</li><li><code>alt_error::Float64</code>: The expected error in altitude in meters.</li><li><code>failed_PRN::Int</code>: The pseudo-random noise (PRN) number of the satellite that has failed or is likely to fail.</li><li><code>prob_of_missed::Float64</code>: The probability of missed detection for the failed satellite.</li><li><code>excluded_meas_err::Float64</code>: The estimated error caused by excluding the measurement from the failed satellite.</li><li><code>standard_deviation::Float64</code>: The standard deviation of the residual errors for all satellites used in the position fix.</li><li><code>valid::Bool</code>: A flag that indicates whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items in the GBS NMEA string. It also takes optional keyword arguments for the system name and the validity flag. It parses the items and assigns them to the corresponding fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L215-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.GGA" href="#NMEAParser.GGA"><code>NMEAParser.GGA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GGA(items::Array{D}; system::AbstractString = &quot;UNKNOWN&quot;, valid = true)</code></pre><p>A struct that represents a Global Positioning System Fix Data (GGA) sentence from the NMEA protocol. It contains information about the GPS system, time, location, fix quality, number of satellites, horizontal dilution of precision (HDOP), altitude, geoidal separation, age of differential corrections, and differential reference station ID.</p><p><strong>Arguments</strong></p><ul><li><code>items::Array{D}</code>: An array of strings that contains the fields of the GGA sentence, separated by commas.</li><li><code>system::AbstractString</code>: An optional keyword argument that specifies the type of GPS system used.   It can be &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;GALILEO&quot;, or &quot;Combined&quot;. The default value is &quot;UNKNOWN&quot;.</li><li><code>valid::Bool</code>: An optional keyword argument that indicates whether the GGA sentence is valid or not. The default value is true.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>GGA</code> object with the following fields:<ul><li><code>system::String</code>: The type of GPS system used.</li><li><code>time::Float64</code>: The UTC time of the fix in seconds.</li><li><code>latitude::Float64</code>: The latitude of the position in decimal degrees.</li><li><code>longitude::Float64</code>: The longitude of the position in decimal degrees.</li><li><code>fix_quality::String</code>: The quality of the fix. It can be one of the following values:   &quot;INVALID&quot;, &quot;GPS (SPS)&quot;, &quot;DGPS&quot;, &quot;PPS&quot;, &quot;REAL TIME KINEMATIC&quot;, &quot;FLOAT RTK&quot;,   &quot;DEAD RECKONING&quot;, &quot;MANUAL INPUT&quot;, or &quot;SIMULATION&quot;.</li><li><code>num_sats::Int</code>: The number of satellites used in the fix.</li><li><code>HDOP::Float64</code>: The horizontal dilution of precision (HDOP) of the fix.</li><li><code>altitude::Float64</code>: The altitude above mean sea level (MSL) in meters.</li><li><code>geoidal_seperation::Float64</code>: The difference between the WGS-84 earth ellipsoid and mean sea level (MSL) in meters.</li><li><code>age_of_differential::Float64</code>: The time since the last SC104 type 1 or 9 update in seconds.   A value of 0 means no differential GPS correction is available.</li><li><code>diff_reference_id::Int</code>: The differential reference station ID.</li><li><code>valid::Bool</code>: Whether the GGA sentence is valid or not.</li></ul></li></ul><p>The GGA sentence is one of the most common sentences used with GPS receivers. It contains information about position, elevation, time, number of satellites used, fix type, and correction age. The message ID for the GGA sentence is “GGA”. Here is an example of a GGA sentence:</p><p><code>$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47</code></p><p>This means that the GPS receiver reported its position as 48 degrees 7.038 minutes north latitude and 11 degrees 31.000 minutes east longitude at 12:35:19 UTC on the current date. The fix type was GPS (SPS), with 8 satellites used and a horizontal dilution of precision (HDOP) of 0.9. The altitude above mean sea level (MSL) was 545.4 meters, and the geoidal separation was 46.9 meters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L3-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.GLL" href="#NMEAParser.GLL"><code>NMEAParser.GLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GLL &lt;: NMEAString</code></pre><p>A struct for handling NMEA message data of type GLL, which contains geographic position and time information.</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: the name of the GNSS system that produced the data (e.g. &quot;GPS&quot;, &quot;GLONASS&quot;, etc.)</li><li><code>latitude::Float64</code>: the latitude of the position in decimal degrees</li><li><code>longitude::Float64</code>: the longitude of the position in decimal degrees</li><li><code>time::Float64</code>: the UTC time of the position in seconds</li><li><code>status::Bool</code>: whether the position is valid (<code>true</code>) or not (<code>false</code>)</li><li><code>mode::Char</code>: the mode indicator of the position fix (e.g. &#39;A&#39; for autonomous, &#39;D&#39; for differential, etc.)</li><li><code>valid::Bool</code>: whether the message data is valid (<code>true</code>) or not (<code>false</code>)</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which should contain the fields of the GLL message in order, separated by commas. Optionally, a keyword argument <code>system</code> can be given to specify the GNSS system name, and a keyword argument <code>valid</code> can be given to indicate the validity of the message data. If not given, these arguments default to &quot;UNKNOWN&quot; and <code>true</code>, respectively.</p><p>The GLL message contains the latitude, longitude, time, and status of the position fix obtained by the receiver. The status indicates whether the position is valid or not, and the mode indicates whether the position is obtained autonomously, differentially, or by other means. The GLL message is useful for applications that need to know the exact location and time of the receiver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L265-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.GSA" href="#NMEAParser.GSA"><code>NMEAParser.GSA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GSA(items::Array{D}; system::AbstractString = &quot;UNKNOWN&quot;, valid = true)</code></pre><p>A struct that represents a GNSS DOP and Active Satellites (GSA) sentence from the NMEA protocol. It contains information about the GPS system, mode, current mode, satellite IDs, position dilution of precision (PDOP), horizontal dilution of precision (HDOP), and vertical dilution of precision (VDOP).</p><p><strong>Arguments</strong></p><ul><li><code>items::Array{D}</code>: An array of strings that contains the fields of the GSA sentence, separated by commas.</li><li><code>system::AbstractString</code>: An optional keyword argument that specifies the type of GPS system used.</li></ul><p>It can be &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;GALILEO&quot;, or &quot;Combined&quot;. The default value is &quot;UNKNOWN&quot;.</p><ul><li><code>valid::Bool</code>: An optional keyword argument that indicates whether the GSA sentence is valid or not. The default value is true.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>GSA</code> object with the following fields:<ul><li><code>system::String</code>: The type of GPS system used.</li><li><code>mode::Char</code>: The mode of operation. It can be &#39;A&#39; for automatic or &#39;M&#39; for manual.</li><li><code>current_mode::Int</code>: The current mode of operation. It can be one of the following values: 1 for no fix, 2 for 2D fix, or 3 for 3D fix.</li><li><code>sat_ids::Vector{Int}</code>: A vector of integers that contains the IDs of the satellites used in the fix.</li><li><code>PDOP::Float64</code>: The position dilution of precision (PDOP) of the fix.</li><li><code>HDOP::Float64</code>: The horizontal dilution of precision (HDOP) of the fix.</li><li><code>VDOP::Float64</code>: The vertical dilution of precision (VDOP) of the fix.</li><li><code>valid::Bool</code>: Whether the GSA sentence is valid or not.</li></ul></li></ul><p>The GSA sentence contains information about the GNSS DOP and active satellites. It indicates the mode of operation, the current mode of operation, the satellite IDs used in the fix, and the position dilution of precision (PDOP), horizontal dilution of precision (HDOP), and vertical dilution of precision (VDOP). The message ID for the GSA sentence is “GSA”. Here is an example of a GSA sentence:</p><p><code>$GNGSA,A,3,21,5,29,25,12,10,26,2,,,,,1.2,0.7,1.0*27</code></p><p>This means that the GNSS receiver was in automatic mode and had a 3D fix using satellites with IDs 21, 5, 29, 25, 12, 10, 26, and 2. The PDOP was 1.2, the HDOP was 0.7, and the VDOP was 1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L98-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.GSV" href="#NMEAParser.GSV"><code>NMEAParser.GSV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GSV &lt;: NMEAString</code></pre><p>A struct for handling NMEA message data of type GSV, which contains information about the GNSS satellites in view.</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: the name of the GNSS system that produced the data (e.g. &quot;GPS&quot;, &quot;GLONASS&quot;, etc.)</li><li><code>msg_total::Int</code>: the total number of GSV messages in this cycle</li><li><code>msg_num::Int</code>: the sequence number of this message in this cycle</li><li><code>sat_total::Int</code>: the total number of satellites in view</li><li><code>SV_data::Vector{Int}</code>: an array of SVData structs, each containing information about one satellite in view</li><li><code>valid::Bool</code>: whether the message data is valid (<code>true</code>) or not (<code>false</code>)</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which should contain the fields of the GSV message in order, separated by commas. Optionally, a keyword argument <code>system</code> can be given to specify the GNSS system name, and a keyword argument <code>valid</code> can be given to indicate the validity of the message data. If not given, these arguments default to &quot;UNKNOWN&quot; and <code>true</code>, respectively.</p><p>The GSV message contains information about the satellites that are in view of the receiver, such as their PRN numbers, elevations, azimuths, and signal-to-noise ratios. The PRN number identifies the satellite uniquely within its system, and the elevation and azimuth indicate the direction of the satellite relative to the receiver. The signal-to-noise ratio measures the quality of the signal received from the satellite. The GSV message is useful for applications that need to know the availability and quality of the satellites that can be used for positioning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L333-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.NMEAData" href="#NMEAParser.NMEAData"><code>NMEAParser.NMEAData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NMEAData()</code></pre><p>A mutable struct that stores the last parsed NMEA messages of different types.</p><p><strong>Fields</strong></p><ul><li><code>last_GGA::Union{Nothing, GGA}</code>: the last GGA message parsed, or nothing if none</li><li><code>last_RMC::Union{Nothing, RMC}</code>: the last RMC message parsed, or nothing if none</li><li><code>last_GSA::Union{Nothing, GSA}</code>: the last GSA message parsed, or nothing if none</li><li><code>last_GSV::Union{Nothing, GSV}</code>: the last GSV message parsed, or nothing if none</li><li><code>last_GBS::Union{Nothing, GBS}</code>: the last GBS message parsed, or nothing if none</li><li><code>last_VTG::Union{Nothing, VTG}</code>: the last VTG message parsed, or nothing if none</li><li><code>last_GLL::Union{Nothing, GLL}</code>: the last GLL message parsed, or nothing if none</li><li><code>last_ZDA::Union{Nothing, ZDA}</code>: the last ZDA message parsed, or nothing if none</li><li><code>last_DTM::Union{Nothing, DTM}</code>: the last DTM message parsed, or nothing if none</li><li><code>last_PASHR::Union{Nothing, PASHR}</code>: the last PASHR message parsed, or nothing if none</li><li><code>last_TWPOS::Union{Nothing, TWPOS}</code>: the last TWPOS message parsed, or nothing if none</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L72-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.PASHR" href="#NMEAParser.PASHR"><code>NMEAParser.PASHR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PASHR(system, time, heading, heading_type, roll, pitch, heave, roll_accuracy,
      pitch_accuracy, heading_accuracy, aiding_code, ins_code, valid)</code></pre><p>A struct that represents a PASHR NMEA string, which is a message that contains position and attitude data from an inertial navigation system (INS).</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The name of the system that produced the message.</li><li><code>time::Float64</code>: The time of the message in seconds since midnight UTC.</li><li><code>heading::Float64</code>: The heading angle in degrees clockwise from north.</li><li><code>heading_type::Char</code>: The type of heading: &#39;T&#39; for true or &#39;M&#39; for magnetic.</li><li><code>roll::Float64</code>: The roll angle in degrees. Positive values indicate right roll.</li><li><code>pitch::Float64</code>: The pitch angle in degrees. Positive values indicate nose up.</li><li><code>heave::Float64</code>: The heave displacement in meters. Positive values indicate upward motion.</li><li><code>roll_accuracy::Float64</code>: The standard deviation of the roll angle in degrees.</li><li><code>pitch_accuracy::Float64</code>: The standard deviation of the pitch angle in degrees.</li><li><code>heading_accuracy::Float64</code>: The standard deviation of the heading angle in degrees.</li><li><code>aiding_code::Int</code>: A code that indicates the type of aiding used by the INS.</li><li><code>ins_code::Int</code>: A code that indicates the status of the INS.</li><li><code>valid::Bool</code>: A flag that indicates whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items in the PASHR NMEA string. It also takes optional keyword arguments for the system name and the validity flag. It parses the items and assigns them to the corresponding fields.</p><p><strong>Example</strong></p><p><code>$PASHR,154155.50,153.17,T,9.68,2.29,-0.07,0.502,0.502,0.959,1*19</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L581-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.RMC" href="#NMEAParser.RMC"><code>NMEAParser.RMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RMC &lt;: NMEAString</code></pre><p>A type that represents a Recommended Minimum Navigation Information (RMC) message, which is one of the most common types of NMEA messages. NMEA stands for National Marine Electronics Association, and it is a standard protocol for communication between marine electronic devices. An RMC message provides information about the position, velocity, time, date, and magnetic variation of a GPS receiver.</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The system identifier, indicating the source of the message (e.g. &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;UNKNOWN&quot;).</li><li><code>time::Float64</code>: The UTC time of the position fix, in seconds since midnight.</li><li><code>status::Bool</code>: The status indicator, either true for active or false for void (invalid).</li><li><code>latitude::Float64</code>: The latitude of the position, in decimal degrees.</li><li><code>longitude::Float64</code>: The longitude of the position, in decimal degrees.</li><li><code>sog::Float64</code>: The speed over ground, in knots.</li><li><code>cog::Float64</code>: The track angle, in degrees true (not magnetic).</li><li><code>day::String</code>: The day of the position fix, in two digits.</li><li><code>month::String</code>: The month of the position fix, in two digits.</li><li><code>year::String</code>: The year of the position fix, in two digits.</li><li><code>magvar::Float64</code>: The magnetic variation, in degrees. A negative value indicates west and a positive value indicates east.</li><li><code>mode::Char</code>: The mode indicator, indicating the type of fix. It can be one of the following values:<ul><li>&#39;A&#39; for autonomous (GPS only)</li><li>&#39;D&#39; for differential (DGPS)</li><li>&#39;E&#39; for estimated</li><li>&#39;F&#39; for float RTK</li><li>&#39;M&#39; for manual input</li><li>&#39;N&#39; for no fix</li><li>&#39;P&#39; for precise</li><li>&#39;R&#39; for real time kinematic</li><li>&#39;S&#39; for simulator</li></ul></li><li><code>valid::Bool</code>: A flag indicating whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items of an RMC sentence. It also takes an optional keyword argument <code>system</code>, which specifies the system identifier. If not given, it defaults to &quot;UNKNOWN&quot;. Another optional keyword argument is <code>valid</code>, which specifies whether the message is valid or not. If not given, it defaults to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L384-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.SVData" href="#NMEAParser.SVData"><code>NMEAParser.SVData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SVData &lt;: NMEAString</code></pre><p>A struct for handling NMEA message data of type SVData, which contains information about one satellite in view of a GNSS receiver.</p><p><strong>Fields</strong></p><ul><li><code>PRN::Int</code>: the PRN number of the satellite, which identifies it uniquely within its system</li><li><code>elevation::Int</code>: the elevation angle of the satellite in degrees, relative to the horizon</li><li><code>azimuth::Int</code>: the azimuth angle of the satellite in degrees, relative to the true north</li><li><code>SNR::Int</code>: the signal-to-noise ratio of the satellite in decibels, which measures the quality of the signal received from the satellite</li></ul><p>The SVData struct is used to store and process information about one satellite that is in view of a GNSS receiver. It is usually part of a GSV message, which contains information about all the satellites in view. The SVData struct can be used to determine the availability and quality of the satellites that can be used for positioning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L310-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.TWPOS" href="#NMEAParser.TWPOS"><code>NMEAParser.TWPOS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TWPOS(system, time, xpose, ypose, zpose, distance, velocity, valid)</code></pre><p>A struct that represents a TWPOS NMEA string, which is a message that contains the position and velocity data from a transponder.</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The name of the system that produced the message.</li><li><code>time::Float64</code>: The time of the message in seconds since midnight UTC.</li><li><code>xpose::Float64</code>: The x-coordinate of the position in meters.</li><li><code>ypose::Float64</code>: The y-coordinate of the position in meters.</li><li><code>zpose::Float64</code>: The z-coordinate of the position in meters.</li><li><code>distance::Float64</code>: The distance from the origin in meters.</li><li><code>velocity::Float64</code>: The velocity in meters per second.</li><li><code>valid::Bool</code>: A flag that indicates whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items in the TWPOS NMEA string. It also takes optional keyword arguments for the system name and the validity flag. It parses the items and converts them to the appropriate units and assigns them to the corresponding fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L644-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.VTG" href="#NMEAParser.VTG"><code>NMEAParser.VTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VTG &lt;: NMEAString</code></pre><p>A type that represents a Track made good and speed over ground (VTG) message, which is one of the types of NMEA messages. NMEA stands for National Marine Electronics Association, and it is a standard protocol for communication between marine electronic devices. A VTG message provides information about the actual track made good and speed over ground of a GPS receiver.</p><p><strong>Fields</strong></p><ul><li><code>system::String</code>: The system identifier, indicating the source of the message (e.g. &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;UNKNOWN&quot;).</li><li><code>CoG_true::Float64</code>: The track made good (degrees true).</li><li><code>CoG_mag::Float64</code>: The track made good (degrees magnetic).</li><li><code>SoG_knots::Float64</code>: The speed over ground, in knots.</li><li><code>SoG_kmhr::Float64</code>: The speed over ground, in kilometers per hour (kph).</li><li><code>mode::Char</code>: The mode indicator, indicating the type of fix. It can be one of the following values:<ul><li>&#39;A&#39; for autonomous (GPS only)</li><li>&#39;D&#39; for differential (DGPS)</li><li>&#39;E&#39; for estimated (dead reckoning) mode</li><li>&#39;M&#39; for manual input mode</li><li>&#39;S&#39; for simulator mode</li><li>&#39;N&#39; for data not valid</li></ul></li><li><code>valid::Bool</code>: A flag indicating whether the message is valid or not.</li></ul><p><strong>Constructor</strong></p><p>The constructor takes an array of strings as an argument, which are the items of a VTG sentence. It also takes an optional keyword argument <code>system</code>, which specifies the system identifier. If not given, it defaults to &quot;UNKNOWN&quot;. Another optional keyword argument is <code>valid</code>, which specifies whether the message is valid or not. If not given, it defaults to true.</p><p><strong>Example</strong></p><p>A message has the following format: <code>$GPVTG,x.x,T,x.x,M,x.x,N,x.x,K,m*hh</code></p><p>For example, the following VTG message:</p><p><code>$GPVTG,140.88,T,M,8.04,N,14.89,K,D*05</code></p><p>Means that:</p><ul><li>The track made good is 140.88 degrees true.</li><li>The track made good is not available in degrees magnetic.</li><li>The speed over ground is 8.04 knots.</li><li>The speed over ground is 14.89 kph.</li><li>The mode indicator is differential (DGPS).</li><li>The checksum data is 05.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L454-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.ZDA" href="#NMEAParser.ZDA"><code>NMEAParser.ZDA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZDA(items::Array{D}; system::AbstractString = &quot;UNKNOWN&quot;, valid = true)</code></pre><p>A struct that represents a Time and Date (ZDA) sentence from the NMEA protocol. It contains information about the GPS system, time, date, and local time zone.</p><p><strong>Arguments</strong></p><ul><li><code>items::Array{D}</code>: An array of strings that contains the fields of the ZDA sentence, separated by commas.</li><li><code>system::AbstractString</code>: An optional keyword argument that specifies the type of GPS system used. It can be &quot;GPS&quot;, &quot;GLONASS&quot;, &quot;GALILEO&quot;, or &quot;Combined&quot;. The default value is &quot;UNKNOWN&quot;.</li><li><code>valid::Bool</code>: An optional keyword argument that indicates whether the ZDA sentence is valid or not. The default value is true.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>ZDA</code> object with the following fields:<ul><li><code>system::String</code>: The type of GPS system used.</li><li><code>time::Float64</code>: The UTC time of the fix in seconds.</li><li><code>day::Int</code>: The day of the month (1-31).</li><li><code>month::Int</code>: The month of the year (1-12).</li><li><code>year::Int</code>: The year (four digits).</li><li><code>zone_hrs::Int</code>: The local time zone offset from UTC in hours.</li><li><code>zone_mins::Int</code>: The local time zone offset from UTC in minutes.</li><li><code>valid::Bool</code>: Whether the ZDA sentence is valid or not.</li></ul></li></ul><p>An example of a ZDA sentence is:</p><p><code>$GPZDA,201530.00,04,07,2002,00,00*60</code></p><p>This means that the GPS system reported the date and time as 20:15:30.00 UTC on July 4th, 2002, with no local time zone offset1.</p><p>The purpose of the ZDA sentence is to provide a reliable and accurate source of date and time information for applications that require synchronization or logging. For example, some scientific instruments or sensors may need to record the exact time of their measurements or events. The ZDA sentence can also be used to adjust the internal clock of the receiver or other devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/types.jl#L161-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Tuple{AbstractString}" href="#Base.parse-Tuple{AbstractString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(nmea_string::AbstractString)</code></pre><p>A function that parses a NMEA string, which is a standard format for data transmission from marine and navigation devices.</p><p><strong>Arguments</strong></p><ul><li><code>nmea_string::AbstractString</code>: The NMEA string to be parsed.</li></ul><p><strong>Returns</strong></p><p>A struct that represents the type and content of the NMEA string, such as DTM, GBS, GGA, GLL, GSA, GSV, RMC, VTG, ZDA, PASHR, or TWPOS. The struct has fields that correspond to the items in the NMEA string.</p><p><strong>Errors</strong></p><p>Throws an <code>ArgumentError</code> if the NMEA string is not supported or has an invalid format.</p><p><strong>Algorithm</strong></p><p>The function splits the NMEA string by the &#39;*&#39; character and checks the checksum of the message. It then splits the message by the &#39;,&#39; character and extracts the header and the items. It determines the system name from the header and calls the appropriate constructor for the corresponding struct type. If no matching struct type is found, it throws an <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!-Tuple{NMEAData, Type{GGA}}" href="#Base.pop!-Tuple{NMEAData, Type{GGA}}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pop!(nmea_data::NMEAData, ::Type{T}) where T &lt;: NMEAString</code></pre><p>Pop the last received message of type T from the NMEAData object nmea_data and return it. If no message of type T has been received, throw an UndefVarError. This function extends the Base.pop! function for NMEAData objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser._dms_to_dd-Tuple{SubString, SubString}" href="#NMEAParser._dms_to_dd-Tuple{SubString, SubString}"><code>NMEAParser._dms_to_dd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_dms_to_dd(dms::SubString, hemi::SubString)</code></pre><p>Converts a string representing degrees, minutes and seconds (DMS) to decimal degrees.</p><p><strong>Arguments</strong></p><ul><li><code>dms</code>: a substring representing degrees, minutes and seconds</li><li><code>hemi</code>: a substring representing the hemisphere</li></ul><p><strong>Returns</strong></p><ul><li><code>dec_degrees</code>: the decimal degree representation of the input DMS</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">dms = &quot;4807.038&quot;
hemi = &quot;N&quot;
dec_degrees = _dms_to_dd(dms, hemi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L117-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser._hms_to_secs-Tuple{SubString}" href="#NMEAParser._hms_to_secs-Tuple{SubString}"><code>NMEAParser._hms_to_secs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_hms_to_secs(hms::SubString)</code></pre><p>Converts a string representing hours, minutes and seconds (HMS) to seconds.</p><p><strong>Arguments</strong></p><ul><li><code>hms</code>: a substring representing hours, minutes and seconds</li></ul><p><strong>Returns</strong></p><ul><li><code>seconds</code>: the number of seconds represented by the input HMS</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">hms = &quot;123519&quot;
seconds = _hms_to_secs(hms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L153-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.get_system-Tuple{SubString}" href="#NMEAParser.get_system-Tuple{SubString}"><code>NMEAParser.get_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_system(mtype::SubString)</code></pre><p>Determine the system type based on the input <code>mtype</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mtype</code>: A <code>SubString</code> representing the message type.</li></ul><p><strong>Returns</strong></p><ul><li>A string representing the system type. Possible values are <code>&quot;GPS&quot;</code>, <code>&quot;GLONASS&quot;</code>, <code>&quot;GALILEO&quot;</code>, <code>&quot;COMBINED&quot;</code>, and <code>&quot;UNKNOWN&quot;</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">get_system(&quot;$GPGGA&quot;) # &quot;GPS&quot;
get_system(&quot;$GLGSV&quot;) # &quot;GLONASS&quot;
get_system(&quot;$GAGGA&quot;) # &quot;GALILEO&quot;
get_system(&quot;$GNGNS&quot;) # &quot;COMBINED&quot;
get_system(&quot;$PMTK&quot;)  # &quot;UNKNOWN&quot;</code></pre><p>TODO: update <code>get_system</code> to cover all common system types AI = Alarm Indicator, (AIS?) AP = Auto Pilot (pypilot?) BD = BeiDou (China) CD = Digital Selective Calling (DSC) EC = Electronic Chart Display &amp; Information System (ECDIS) GA = Galileo Positioning System GB = BeiDou (China) GI = NavIC, IRNSS (India) GL = GLONASS, according to IEIC 61162-1 GN = Combination of multiple satellite systems (NMEA 1083) GP = Global Positioning System receiver GQ = QZSS regional GPS augmentation system (Japan) HC = Heading/Compass HE = Gyro, north seeking II = Integrated Instrumentation IN = Integrated Navigation LC = Loran-C receiver (obsolete) Pxxx = Proprietary (Vendor specific) PQ = QZSS (Quectel Quirk) QZ = QZSS regional GPS augmentation system (Japan) SD = Depth Sounder ST = Skytraq TI = Turn Indicator YX = Transducer WI = Weather Instrument</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.is_string_supported-Tuple{AbstractString}" href="#NMEAParser.is_string_supported-Tuple{AbstractString}"><code>NMEAParser.is_string_supported</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_string_supported(nmea_string::AbstractString)</code></pre><p>Check if the input NMEA string type is supported.</p><p><strong>Arguments</strong></p><ul><li><code>nmea_string::AbstractString</code>: The NMEA string to be checked.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the NMEA string is supported, <code>false</code> otherwise.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; is_string_supported(&quot;$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L79-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.parse_msg!-Tuple{NMEAData, AbstractString}" href="#NMEAParser.parse_msg!-Tuple{NMEAData, AbstractString}"><code>NMEAParser.parse_msg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_msg!(s::NMEAData, line::AbstractString)</code></pre><p>Parse a line of NMEA 0183 data and update the state of an NMEAData object.</p><p><strong>Arguments</strong></p><p>s : NMEAData     An object that stores the parsed data from NMEA messages. line : AbstractString     A string that contains a valid NMEA 0183 message.</p><p><strong>Returns</strong></p><p>DataType     The type of the parsed message, or Nothing if the message is not supported.</p><p><strong>Errors</strong></p><p>ArgumentError     If the line is not a valid NMEA 0183 message.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">s = NMEAData()

julia&gt; d = [ &quot;$GPRMC,154925.820,A,5209.732,N,00600.240,E,001.9,059.8,040123,000.0,W*7E&quot;,
            &quot;$GPGGA,154925.920,5209.732,N,00600.240,E,1,12,1.0,0.0,M,0.0,M,,*63&quot;,
            &quot;$GPGSA,A,3,01,02,03,04,05,06,07,08,09,10,11,12,1.0,1.0,1.0*30&quot;,
            &quot;$GPRMC,154925.920,A,5209.732,N,00600.240,E,001.9,059.8,040123,000.0,W*7F&quot;]
4-element Vector{String}:
 &quot;$GPRMC,154925.820,A,5209.732,N,00600.240,E,001.9,059.8,040123,000.0,W*7E&quot;
 &quot;$GPGGA,154925.920,5209.732,N,00600.240,E,1,12,1.0,0.0,M,0.0,M,,*63&quot;
 &quot;$GPGSA,A,3,01,02,03,04,05,06,07,08,09,10,11,12,1.0,1.0,1.0*30&quot;
 &quot;$GPRMC,154925.920,A,5209.732,N,00600.240,E,001.9,059.8,040123,000.0,W*7F&quot;

 julia&gt; for str in d
            msg_type = parse_msg!(s, str)
            println(msg_type)
        end
 RMC
 GGA
 GSA
 RMC

 julia&gt; s.last_RMC
 RMC(&quot;GPS&quot;, 56965.92, true, 52.1622, 6.004, 1.9, 59.8, &quot;04&quot;, &quot;01&quot;, &quot;23&quot;, -0.0, &#39;A&#39;, true)

 julia&gt; s.last_GGA
 GGA(&quot;GPS&quot;, 56965.92, 52.1622, 6.004, &quot;GPS (SPS)&quot;, 12, 1.0, 0.0, 0.0, 0.0, 0, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L213-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.pos_convert-Tuple{Char, Float64}" href="#NMEAParser.pos_convert-Tuple{Char, Float64}"><code>NMEAParser.pos_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pos_convert(flag::Char, value::Float64)::Float64</code></pre><p>A function that converts a position value from one unit to another.</p><p><strong>Arguments</strong></p><ul><li><code>flag::Char</code>: The flag that indicates the original unit of the position value. Possible values are &#39;F&#39; for feet, &#39;N&#39; for miles, &#39;K&#39; for kilometers, and &#39;M&#39; for meters.</li><li><code>value::Float64</code>: The position value to be converted.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> that represents the position value in meters.</p><p><strong>Errors</strong></p><p>Throws an exception if the flag is not one of the supported values.</p><p><strong>Algorithm</strong></p><p>The function uses a simple formula to convert the position value based on the flag. For example, if the flag is &#39;F&#39;, it divides the value by 0.3048 to get the equivalent value in meters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L177-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.update!-Tuple{NMEAData, GGA}" href="#NMEAParser.update!-Tuple{NMEAData, GGA}"><code>NMEAParser.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update!(s::NMEAData, msg)</code></pre><p>Update the corresponding field of <code>s</code> with the given NMEA message <code>msg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::NMEAData</code>: the NMEA data struct to be updated</li><li><code>msg</code>: an NMEA message of type GGA, RMC, GSA, GSV, GBS, VTG, GLL, ZDA, DTM, PASHR or TWPOS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.update-Tuple{NMEAData, GGA}" href="#NMEAParser.update-Tuple{NMEAData, GGA}"><code>NMEAParser.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update(s::NMEAData, msg::T) where T &lt;: NMEAString</code></pre><p>Update the last received message of type T in the NMEAData object s with the given message msg. Return the updated NMEAData object s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/parse.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMEAParser.vel_convert-Tuple{Char, Float64}" href="#NMEAParser.vel_convert-Tuple{Char, Float64}"><code>NMEAParser.vel_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vel_convert(flag::Char, value::Float64)::Float64</code></pre><p>A function that converts a velocity value from one unit to another.</p><p><strong>Arguments</strong></p><ul><li><code>flag::Char</code>: The flag that indicates the original unit of the velocity value. Possible values are &#39;N&#39; for knots, &#39;K&#39; for kilometers per hour, and &#39;M&#39; for meters per second.</li><li><code>value::Float64</code>: The velocity value to be converted.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> that represents the velocity value in meters per second.</p><p><strong>Errors</strong></p><p>Throws an exception if the flag is not one of the supported values.</p><p><strong>Algorithm</strong></p><p>The function uses a simple formula to convert the velocity value based on the flag. For example, if the flag is &#39;N&#39;, it multiplies the value by 1.94384449244 to get the equivalent value in meters per second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NickMcSweeney/NMEAParser.jl/blob/defc86f8760e2fc5deb233a3cd0383fa4a4b59e8/src/utils.jl#L217-L237">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 22 July 2023 05:50">Saturday 22 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
